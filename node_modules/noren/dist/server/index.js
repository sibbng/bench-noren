/* IMPORT */
import makeNakedPromise from 'promise-make-naked';
import Router from '../router/index.js';
import { castError, isPromise } from './utils.js';
/* MAIN */
//TODO: Add a basic way to serve static files
class Server extends Router {
    /* API */
    async handle(req, res) {
        //TODO: This function is a bit ugly, though it's also kinda complicated, maybe it can be written better?
        const { promise: done, resolve: resolveDone } = makeNakedPromise();
        const results = [];
        async function exec(handler, args) {
            if (handler.length <= args.length) { // Implicit "next" behavior, assuming this is the last handler
                if (args.length === 3) { // Error handler
                    await handler(args[2], args[0], args[1]);
                }
                else { // Request handler
                    await handler(args[0], args[1]);
                }
                return res.ended || false;
            }
            else { // Explicit "next" behavior, assuming this is a middleware
                const { promise, resolve, reject } = makeNakedPromise();
                const result = handler(...args, (errorOrDone) => {
                    (errorOrDone && errorOrDone !== true) ? reject(errorOrDone) : resolve(!!errorOrDone);
                    return done;
                });
                if (res.ended)
                    resolve(true);
                if (isPromise(result))
                    result.finally(() => res.ended && resolve(true));
                const finished = await promise;
                results.push(result);
                return res.ended || finished;
            }
        }
        const method = req.method.toUpperCase();
        const path = decodeURIComponent(req.path);
        try {
            const route = this.route(method, path);
            let finished = false;
            if (route) {
                res.code(200);
                req.params = route.params;
                const handlers = route.route.handlers;
                for (let i = 0, l = handlers.length; i < l; i++) {
                    finished = await exec(handlers[i], [req, res]);
                    if (finished)
                        break;
                }
            }
            else {
                res.code(404);
                const handlers = this.handlers;
                for (let i = 0, l = handlers.length; i < l; i++) {
                    finished = await exec(handlers[i], [req, res]);
                    if (finished)
                        break;
                }
                if (!finished) {
                    if (this.notFoundHandler) {
                        await exec(this.notFoundHandler, [req, res]);
                    }
                    else {
                        res.status(404);
                    }
                }
            }
        }
        catch (exception) {
            if (this.errorHandler) {
                res.status(500, null);
                try {
                    const error = castError(exception);
                    await exec(this.errorHandler, [req, res, error]);
                }
                catch (exception) {
                    res.status(500);
                    console.error(exception);
                }
            }
            else {
                res.status(500);
                console.error(exception);
            }
        }
        resolveDone();
        await Promise.allSettled(results);
        return res;
    }
    onError(handler) {
        if (this.errorHandler)
            throw new Error('An error handler has already been set');
        this.errorHandler = handler;
        return this;
    }
    onNotFound(handler) {
        if (this.notFoundHandler)
            throw new Error('A not-found handler has already been set');
        this.notFoundHandler = handler;
        return this;
    }
}
/* EXPORT */
export default Server;

/* MAIN */
const castArrayBuffer = (uint8) => {
    const { buffer, byteOffset, byteLength } = uint8;
    if (!byteOffset && byteLength === buffer.byteLength) { // Full-length
        return buffer;
    }
    else { // Partial
        return buffer.slice(byteOffset, byteOffset + byteLength);
    }
};
const castError = (exception) => {
    if (isError(exception))
        return exception;
    if (isString(exception))
        return new Error(exception);
    return new Error('Unknown error');
};
const isArray = (value) => {
    return Array.isArray(value);
};
const isError = (value) => {
    return value instanceof Error;
};
const isFunction = (value) => {
    return typeof value === 'function';
};
const isPromise = (value) => {
    return value instanceof Promise;
};
const isStream = (value) => {
    return value instanceof ReadableStream;
};
const isString = (value) => {
    return typeof value === 'string';
};
const memoize = (fn) => {
    const cache = new Map();
    return (arg) => {
        const cached = cache.get(arg);
        if (cached)
            return cached;
        const result = fn(arg);
        cache.set(arg, result);
        return result;
    };
};
const Once = () => {
    const once = (fn) => {
        const symbol = Symbol();
        return function () {
            return this[symbol] || (this[symbol] = fn.call(this));
        };
    };
    return (target, key, descriptor) => {
        if (isFunction(descriptor.value)) {
            descriptor.value = once(descriptor.value);
        }
        else if (isFunction(descriptor.get)) {
            descriptor.get = once(descriptor.get);
        }
        else {
            throw new Error('@Once can only be called on methods and getters');
        }
    };
};
/* EXPORT */
export { castArrayBuffer, castError, isArray, isError, isFunction, isPromise, isStream, isString, memoize, Once };

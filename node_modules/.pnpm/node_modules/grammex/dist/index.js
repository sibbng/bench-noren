/* IMPORT */
import { isArray, isFunction, isFunctionNullary, isNumber, isObject, isRegExp, isString, isUndefined, memoize } from './utils.js';
/* MAIN */
const parse = (input, rule, options = {}) => {
    const state = { cache: {}, input, index: 0, indexMax: 0, options, output: [] };
    const matched = resolve(rule)(state);
    if (matched && state.index === input.length) {
        return state.output;
    }
    else {
        throw new Error(`Failed to parse at index ${state.indexMax}`);
    }
};
const validate = (input, rule, options = {}) => {
    try {
        parse(input, rule, options);
        return true;
    }
    catch {
        return false;
    }
};
/* RULES - PRIMIVITE */
const match = (target, handler) => {
    return isArray(target) ? chars(target, handler) : isString(target) ? string(target, handler) : regex(target, handler);
};
const chars = (target, handler) => {
    const charCodes = {};
    for (const char of target) {
        if (char.length !== 1)
            throw new Error(`Invalid character: "${char}"`);
        const charCode = char.charCodeAt(0);
        charCodes[charCode] = true;
    }
    return (state) => {
        const indexStart = state.index;
        const input = state.input;
        while (state.index < input.length) {
            const charCode = input.charCodeAt(state.index);
            if (!(charCode in charCodes))
                break;
            state.index += 1;
        }
        const indexEnd = state.index;
        if (indexEnd > indexStart) {
            if (!isUndefined(handler) && !state.options.silent) {
                const target = state.input.slice(indexStart, indexEnd);
                const output = isFunction(handler) ? handler(target, input, String(indexStart)) : handler;
                if (!isUndefined(output)) {
                    state.output.push(output);
                }
            }
            state.indexMax = Math.max(state.indexMax, state.index);
        }
        return true;
    };
};
const regex = (target, handler) => {
    const source = target.source;
    const flags = target.flags.replace(/y|$/, 'y');
    const re = new RegExp(source, flags);
    return memoizable((state) => {
        re.lastIndex = state.index;
        const match = re.exec(state.input);
        if (match) {
            if (!isUndefined(handler) && !state.options.silent) {
                const output = isFunction(handler) ? handler(...match, state.input, String(state.index)) : handler;
                if (!isUndefined(output)) {
                    state.output.push(output);
                }
            }
            state.index += match[0].length;
            state.indexMax = Math.max(state.indexMax, state.index);
            return true;
        }
        else {
            return false;
        }
    });
};
const string = (target, handler) => {
    return (state) => {
        const isMatch = state.input.startsWith(target, state.index);
        if (isMatch) {
            if (!isUndefined(handler) && !state.options.silent) {
                const output = isFunction(handler) ? handler(target, state.input, String(state.index)) : handler;
                if (!isUndefined(output)) {
                    state.output.push(output);
                }
            }
            state.index += target.length;
            state.indexMax = Math.max(state.indexMax, state.index);
            return true;
        }
        else {
            return false;
        }
    };
};
/* RULES - REPETITION */
const repeat = (rule, min, max, handler) => {
    const erule = resolve(rule);
    return memoizable(handleable(backtrackable((state) => {
        let repetitions = 0;
        while (repetitions < max) {
            const index = state.index;
            const matched = erule(state);
            if (!matched)
                break;
            repetitions += 1;
            if (state.index === index)
                break;
        }
        return (repetitions >= min);
    }), handler));
};
const optional = (rule, handler) => {
    return repeat(rule, 0, 1, handler);
};
const star = (rule, handler) => {
    return repeat(rule, 0, Infinity, handler);
};
const plus = (rule, handler) => {
    return repeat(rule, 1, Infinity, handler);
};
/* RULES - SEQUENCE */
const and = (rules, handler) => {
    const erules = rules.map(resolve);
    return memoizable(handleable(backtrackable((state) => {
        for (let i = 0, l = erules.length; i < l; i++) {
            if (!erules[i](state))
                return false;
        }
        return true;
    }), handler));
};
/* RULES - CHOICE */
const or = (rules, handler) => {
    const erules = rules.map(resolve);
    return memoizable(handleable((state) => {
        for (let i = 0, l = erules.length; i < l; i++) {
            if (erules[i](state))
                return true;
        }
        return false;
    }, handler));
};
const jump = (rules, handler) => {
    const erules = {};
    for (const char in rules) {
        if (char.length !== 1 && char !== 'default')
            throw new Error(`Invalid jump character: "${char}"`);
        erules[char] = resolve(rules[char]);
    }
    return handleable((state) => {
        const char = state.input[state.index];
        const erule = erules[char] || erules['default'];
        if (erule) {
            return erule(state);
        }
        else {
            return false;
        }
    }, handler);
};
/* RULES - LOOKAHEAD */
const lookahead = (rule, result) => {
    const erule = resolve(rule);
    return backtrackable((state) => {
        return erule(state) === result;
    }, true);
};
const negative = (rule) => {
    return lookahead(rule, false);
};
const positive = (rule) => {
    return lookahead(rule, true);
};
/* RULES - DECORATORS */
const backtrackable = (rule, force = false) => {
    const erule = resolve(rule);
    return (state) => {
        const index = state.index;
        const length = state.output.length;
        const matched = erule(state);
        if (!matched || force) {
            state.index = index;
            if (state.output.length !== length) { // This can be surprisingly slow otherwise
                state.output.length = length;
            }
        }
        return matched;
    };
};
const handleable = (rule, handler) => {
    const erule = resolve(rule);
    if (!handler)
        return erule;
    return (state) => {
        if (state.options.silent)
            return erule(state);
        const length = state.output.length;
        const matched = erule(state);
        if (matched) {
            const outputs = state.output.splice(length, Infinity);
            const output = handler(outputs);
            if (!isUndefined(output)) {
                state.output.push(output);
            }
            return true;
        }
        else {
            return false;
        }
    };
};
const memoizable = (() => {
    let RULE_ID = 0; // This is faster than using symbols, for some reason
    return (rule) => {
        const erule = resolve(rule);
        const ruleId = (RULE_ID += 1);
        return (state) => {
            var _a;
            if (state.options.memoization === false)
                return erule(state);
            const indexStart = state.index;
            const cache = ((_a = state.cache)[ruleId] || (_a[ruleId] = new Map()));
            const cached = cache.get(indexStart);
            if (cached === false) {
                return false;
            }
            else if (isNumber(cached)) {
                state.index = cached;
                return true;
            }
            else if (cached) {
                state.index = cached.index;
                if (cached.output?.length) {
                    state.output.push(...cached.output);
                }
                return true;
            }
            else {
                const lengthStart = state.output.length;
                const matched = erule(state);
                if (matched) {
                    const indexEnd = state.index;
                    const lengthEnd = state.output.length;
                    if (lengthEnd > lengthStart) {
                        const output = state.output.slice(lengthStart, lengthEnd);
                        cache.set(indexStart, { index: indexEnd, output });
                    }
                    else {
                        cache.set(indexStart, indexEnd);
                    }
                    return true;
                }
                else {
                    cache.set(indexStart, false);
                    return false;
                }
            }
        };
    };
})();
/* RULES - UTILITIES */
const grammar = (fn) => {
    return fn({
        match: (match),
        repeat: (repeat),
        optional: (optional),
        star: (star),
        plus: (plus),
        and: (and),
        or: (or),
        jump: (jump),
        negative: (negative),
        positive: (positive),
        lazy: (lazy)
    });
};
const lazy = (getter) => {
    let erule;
    return (state) => {
        erule || (erule = resolve(getter()));
        return erule(state);
    };
};
const resolve = memoize((rule) => {
    if (isFunction(rule)) {
        if (isFunctionNullary(rule)) {
            return lazy(rule);
        }
        else {
            return rule;
        }
    }
    if (isString(rule) || isRegExp(rule)) {
        return match(rule);
    }
    if (isArray(rule)) {
        return and(rule);
    }
    if (isObject(rule)) {
        return or(Object.values(rule));
    }
    throw new Error('Invalid rule');
});
/* EXPORT */
export { parse, validate };
export { match };
export { repeat, optional, star, plus };
export { and };
export { or, jump };
export { negative, positive };
export { grammar, lazy };

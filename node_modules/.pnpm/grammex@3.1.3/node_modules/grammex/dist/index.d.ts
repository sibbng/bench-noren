import type { CompoundHandler, PrimitiveHandler, ExplicitRule, ImplicitRule, Rule, Options, State } from './types';
declare const parse: <T>(input: string, rule: Rule<T>, options?: Options) => T[];
declare const validate: <T>(input: string, rule: Rule<T>, options?: Options) => boolean;
declare const match: <T>(target: RegExp | string | string[], handler?: T | PrimitiveHandler<T> | undefined) => ExplicitRule<T>;
declare const repeat: <T>(rule: Rule<T>, min: number, max: number, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
declare const optional: <T>(rule: Rule<T>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
declare const star: <T>(rule: Rule<T>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
declare const plus: <T>(rule: Rule<T>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
declare const and: <T>(rules: Rule<T>[], handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
declare const or: <T>(rules: Rule<T>[], handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
declare const jump: <T>(rules: Record<string, Rule<T>>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
declare const negative: <T>(rule: Rule<T>) => ExplicitRule<T>;
declare const positive: <T>(rule: Rule<T>) => ExplicitRule<T>;
declare const grammar: <T, U>(fn: (operators: {
    match: (target: RegExp | string | string[], handler?: T | PrimitiveHandler<T> | undefined) => ExplicitRule<T>;
    repeat: (rule: Rule<T>, min: number, max: number, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
    optional: (rule: Rule<T>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
    star: (rule: Rule<T>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
    plus: (rule: Rule<T>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
    and: (rules: Rule<T>[], handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
    or: (rules: Rule<T>[], handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
    jump: (rules: Record<string, Rule<T>>, handler?: CompoundHandler<T> | undefined) => ExplicitRule<T>;
    negative: (rule: Rule<T>) => ExplicitRule<T>;
    positive: (rule: Rule<T>) => ExplicitRule<T>;
    lazy: (getter: Function) => ExplicitRule<T>;
}) => U) => U;
declare const lazy: <T = any>(getter: Function) => ExplicitRule<T>;
export { parse, validate };
export { match };
export { repeat, optional, star, plus };
export { and };
export { or, jump };
export { negative, positive };
export { grammar, lazy };
export type { CompoundHandler, PrimitiveHandler, ExplicitRule, ImplicitRule, Rule, Options, State };
